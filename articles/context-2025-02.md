---
title: "Context Management 2025 - 02. ãƒ¢ãƒ€ãƒ³ãªContext Managementã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£"
emoji: "ğŸ¤–"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [agent, AI, LLM, Tech]
published: true
publication_name: "singularity"
---

# 2. ãƒ¢ãƒ€ãƒ³ãªContext Managementã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£


## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### å…¨ä½“æ§‹æˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                     â”‚
â”‚  - User Interface (CLI/GUI/API)                         â”‚
â”‚  - Task Definition                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ModernContextEngine (Orchestrator)          â”‚
â”‚  - ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ«ãƒ¼ãƒ—                                        â”‚
â”‚  - ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†ï¼ˆPlanning â†’ Executing â†’ Reflectingï¼‰      â”‚
â”‚  - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â†“                  â†“                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Context  â”‚      â”‚   Tool   â”‚      â”‚ Message  â”‚
â”‚ Builder  â”‚      â”‚Projector â”‚      â”‚ Manager  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“                  â†“                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Layered State                          â”‚
â”‚  L0: System/Policy                                       â”‚
â”‚  L1: Task Contract                                       â”‚
â”‚  L2: Runtime State                                       â”‚
â”‚  L3: Memory (Short/Episodic/Semantic/Procedural)        â”‚
â”‚  L4: Evidence (Observations/RAG)                        â”‚
â”‚  L5: Work Buffer                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â†“                  â†“                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Condensa- â”‚      â”‚  Token   â”‚      â”‚ Observa- â”‚
â”‚tion      â”‚      â”‚ Counter  â”‚      â”‚ bility   â”‚
â”‚ Engine   â”‚      â”‚          â”‚      â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   LLM Provider Layer                     â”‚
â”‚  - Anthropic (Claude)                                    â”‚
â”‚  - OpenAI (GPT)                                          â”‚
â”‚  - DeepSeek                                              â”‚
â”‚  - Other providers                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Persistence Layer                      â”‚
â”‚  - State Storage (JSON/DB)                               â”‚
â”‚  - Checkpoint Service (Shadow Git)                       â”‚
â”‚  - Telemetry Service                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è¨­è¨ˆåŸå‰‡

1. **é–¢å¿ƒã®åˆ†é›¢**: å„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæ˜ç¢ºãªè²¬å‹™ã‚’æŒã¤
2. **éšå±¤çš„çµ„ç¹”åŒ–**: å„ªå…ˆåº¦ã¨å½¹å‰²ã§æƒ…å ±ã‚’éšå±¤åŒ–
3. **éç ´å£Šçš„æ“ä½œ**: ãƒ‡ãƒ¼ã‚¿ã¯å‰Šé™¤ã›ãšã‚¿ã‚°ä»˜ã‘
4. **å‹•çš„é©å¿œ**: çŠ¶æ…‹ã«å¿œã˜ã¦ãƒ„ãƒ¼ãƒ«ã¨ã‚¹ã‚­ãƒ¼ãƒã‚’å¤‰åŒ–
5. **è¦³æ¸¬å¯èƒ½æ€§**: ã™ã¹ã¦ã®æ“ä½œã‚’ãƒˆãƒ¬ãƒ¼ã‚¹ãƒ»è¨ˆæ¸¬

---

## éšå±¤çš„Stateè¨­è¨ˆï¼ˆL0-L5ï¼‰

### å®Œå…¨ãªå‹å®šç¾©

```typescript
/**
 * L0: System / Policy
 * æœ€é«˜å„ªå…ˆåº¦ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ä¸å¤‰
 */
interface SystemLayer {
  // ã‚·ã‚¹ãƒ†ãƒ ãƒ­ãƒ¼ãƒ«å®šç¾©
  role: {
    name: string           // ä¾‹: "AI Coding Assistant"
    description: string    // è©³ç´°ãªå½¹å‰²èª¬æ˜
    capabilities: string[] // å¯èƒ½ãªã“ã¨
    limitations: string[]  // ã§ããªã„ã“ã¨
  }

  // å®‰å…¨ãƒãƒªã‚·ãƒ¼ï¼ˆConstitutional AIæ–¹å¼ï¼‰
  policies: Policy[]

  // ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆ¶ç´„
  constraints: {
    maxExecutionTime?: number     // æœ€å¤§å®Ÿè¡Œæ™‚é–“ï¼ˆç§’ï¼‰
    maxToolCalls?: number         // æœ€å¤§ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—æ•°
    maxFileSize?: number          // æœ€å¤§ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º
    allowedDomains?: string[]     // è¨±å¯ã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³
    forbiddenPaths?: string[]     // ç¦æ­¢ãƒ‘ã‚¹
  }

  // ç›£æŸ»è¦ä»¶
  auditRequirements: {
    logToolCalls: boolean         // ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã‚’ãƒ­ã‚°
    logDecisions: boolean         // æ„æ€æ±ºå®šã‚’ãƒ­ã‚°
    requireApproval: string[]     // æ‰¿èªãŒå¿…è¦ãªæ“ä½œ
    retentionDays: number         // ãƒ­ã‚°ä¿æŒæœŸé–“
  }
}

interface Policy {
  id: string
  category: 'safety' | 'privacy' | 'compliance' | 'ethics'
  rule: string                    // ä¾‹: "Never expose user credentials"
  priority: number                // å„ªå…ˆåº¦ï¼ˆé«˜ã„ã»ã©é‡è¦ï¼‰
  enforcement: 'hard' | 'soft'    // hard=æ‹’å¦ã€soft=è­¦å‘Š
}

/**
 * L1: Task Contract
 * ã‚¿ã‚¹ã‚¯ã®å®šç¾©ã¨æˆåŠŸæ¡ä»¶
 */
interface TaskLayer {
  // æœ€çµ‚ç›®æ¨™
  goal: string

  // æˆåŠŸæ¡ä»¶ï¼ˆæ˜ç¢ºã«å®šç¾©ï¼‰
  successCriteria: Criterion[]

  // å‡ºåŠ›å½¢å¼ï¼ˆæ§‹é€ åŒ–ï¼‰
  outputFormat: {
    type: 'json' | 'markdown' | 'code' | 'mixed'
    schema?: JSONSchema           // JSON Schemaã§å®šç¾©
    examples?: string[]           // å‡ºåŠ›ä¾‹
  }

  // åˆ¶ç´„
  constraints: {
    timeLimit?: number            // åˆ¶é™æ™‚é–“
    budgetLimit?: number          // ã‚³ã‚¹ãƒˆåˆ¶é™
    qualityThreshold?: number     // å“è³ªã—ãã„å€¤
  }

  // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
  metadata: {
    createdAt: number
    createdBy: string
    priority: 'low' | 'medium' | 'high' | 'critical'
    tags: string[]
  }
}

interface Criterion {
  id: string
  description: string
  measurable: boolean             // æ¸¬å®šå¯èƒ½ã‹
  validator?: (result: any) => boolean  // æ¤œè¨¼é–¢æ•°
}

/**
 * L2: Runtime State
 * å®Ÿè¡Œæ™‚ã®å‹•çš„ãªçŠ¶æ…‹
 */
interface RuntimeLayer {
  // ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚º
  phase: Phase

  // æ¨©é™ï¼ˆå‹•çš„ã«å¤‰åŒ–ï¼‰
  permissions: Permission[]

  // ç’°å¢ƒ
  environment: Environment

  // å®Ÿè¡Œå±¥æ­´
  executionHistory: {
    toolCalls: ToolCall[]         // ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—å±¥æ­´
    decisions: Decision[]         // æ„æ€æ±ºå®šå±¥æ­´
    errors: Error[]               // ã‚¨ãƒ©ãƒ¼å±¥æ­´
    warnings: Warning[]           // è­¦å‘Šå±¥æ­´
  }

  // å¤±æ•—å±¥æ­´ï¼ˆãƒªãƒˆãƒ©ã‚¤åˆ¤å®šç”¨ï¼‰
  failureHistory: Failure[]

  // ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨çŠ¶æ³
  resources: {
    tokenUsage: {
      input: number
      output: number
      cached: number
    }
    apiCalls: number
    executionTime: number         // ãƒŸãƒªç§’
    cost: number                  // USD
  }
}

type Phase =
  | 'initializing'
  | 'planning'
  | 'executing'
  | 'reflecting'
  | 'verifying'
  | 'completed'
  | 'failed'

type Permission =
  | 'read'
  | 'write'
  | 'execute'
  | 'delete'
  | 'admin'
  | 'deploy'

type Environment = 'dev' | 'staging' | 'prod'

interface ToolCall {
  id: string
  tool: string
  input: any
  output: any
  timestamp: number
  duration: number
  success: boolean
}

interface Decision {
  id: string
  description: string
  rationale: string               // ç†ç”±
  alternatives: string[]          // æ¤œè¨ã—ãŸä»£æ›¿æ¡ˆ
  timestamp: number
}

interface Failure {
  tool: string
  error: string
  timestamp: number
  retryCount: number
}

/**
 * L3: Memory
 * è¤‡æ•°ç¨®é¡ã®è¨˜æ†¶ã‚’ç®¡ç†
 */
interface MemoryLayer {
  // çŸ­æœŸãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒª
  shortTerm: ShortTermMemory

  // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜æ†¶ï¼ˆå‡ºæ¥äº‹ï¼‰
  episodic: EpisodicMemory

  // æ„å‘³è¨˜æ†¶ï¼ˆäº‹å®Ÿï¼‰
  semantic: SemanticMemory

  // æ‰‹ç¶šãè¨˜æ†¶ï¼ˆã‚„ã‚Šæ–¹ï¼‰
  procedural: ProceduralMemory
}

interface ShortTermMemory {
  // ä½œæ¥­å¤‰æ•°ï¼ˆä¸€æ™‚çš„ãªå€¤ï¼‰
  workingVariables: Record<string, any>

  // ç›´è¿‘ã®ã‚¿ãƒ¼ãƒ³ï¼ˆ3-5ä»¶ï¼‰
  recentTurns: Message[]

  // ç›´è¿‘ã®è¦³æ¸¬ï¼ˆãƒ„ãƒ¼ãƒ«çµæœãªã©ï¼‰
  recentObservations: Observation[]

  // TTLï¼ˆTime To Liveï¼‰
  ttl: number                     // ãƒŸãƒªç§’
}

interface EpisodicMemory {
  // è¦ç´„æ¸ˆã¿ã®éå»ã®ä¼šè©±
  summaries: Summary[]

  // é‡è¦ãªæ„æ€æ±ºå®š
  decisions: Decision[]

  // ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³
  milestones: Milestone[]

  // æœ€å¤§ä¿æŒæ•°
  maxEntries: number
}

interface Summary {
  id: string
  text: string
  condensedFrom: string[]         // å…ƒã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ID
  timestamp: number
  tokenCount: number
  relevance?: number              // ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã¸ã®é–¢é€£åº¦
}

interface Milestone {
  id: string
  event: string                   // ä¾‹: "Project initialized"
  timestamp: number
  significance: 'low' | 'medium' | 'high'
}

interface SemanticMemory {
  // ç¢ºå®šäº‹å®Ÿ
  facts: Fact[]

  // å®šç¾©ï¼ˆç”¨èªã€æ¦‚å¿µï¼‰
  definitions: Definition[]

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®š
  preferences: Preference[]

  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆçŸ¥è­˜
  projectKnowledge: Knowledge[]
}

interface Fact {
  id: string
  content: string
  source: string                  // å‡ºå…¸
  confidence: number              // 0-1
  timestamp: number
  verified: boolean
}

interface Definition {
  term: string
  definition: string
  context: string                 // ä½¿ç”¨æ–‡è„ˆ
  examples?: string[]
}

interface Preference {
  category: string                // ä¾‹: "code_style", "language"
  key: string
  value: any
  timestamp: number
}

interface Knowledge {
  id: string
  category: string                // ä¾‹: "architecture", "dependencies"
  content: string
  references: string[]            // é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
  timestamp: number
}

interface ProceduralMemory {
  // ã‚¹ã‚­ãƒ«ï¼ˆå®Ÿè¡Œå¯èƒ½ãªæ‰‹ç¶šãï¼‰
  skills: Skill[]

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå†åˆ©ç”¨å¯èƒ½ãªãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  templates: Template[]

  // ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
  checklists: Checklist[]

  // æ‰‹é †æ›¸
  procedures: Procedure[]
}

interface Skill {
  id: string
  name: string
  description: string
  steps: string[]                 // æ‰‹é †
  requiredTools: string[]
  prerequisites: string[]
  examples?: string[]
}

interface Template {
  id: string
  name: string
  category: string
  content: string
  variables: string[]             // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
  usageCount: number
}

interface Checklist {
  id: string
  name: string
  items: ChecklistItem[]
  completed: boolean
}

interface ChecklistItem {
  description: string
  completed: boolean
  optional: boolean
}

interface Procedure {
  id: string
  name: string
  description: string
  phases: ProcedurePhase[]
  estimatedDuration?: number
}

interface ProcedurePhase {
  name: string
  steps: string[]
  validations: string[]
}

/**
 * L4: Evidence
 * è¦³æ¸¬ã¨æ¤œç´¢çµæœ
 */
interface EvidenceLayer {
  // ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œçµæœï¼ˆè¦³æ¸¬ï¼‰
  observations: Observation[]

  // RAGæ¤œç´¢çµæœ
  ragResults: RAGResult[]

  // å¼•ç”¨
  citations: Citation[]

  // æ¸¬å®šå€¤
  measurements: Measurement[]
}

interface Observation {
  id: string
  source: 'tool' | 'user' | 'system'
  tool?: string                   // ãƒ„ãƒ¼ãƒ«å
  result: any                     // çµæœ
  timestamp: number
  relevance?: number              // é–¢é€£åº¦
  ttl: number                     // æœ‰åŠ¹æœŸé™
}

interface RAGResult {
  id: string
  query: string
  source: string                  // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLç­‰
  content: string
  relevance: number               // 0-1
  metadata: {
    page?: number
    section?: string
    timestamp?: number
  }
}

interface Citation {
  id: string
  text: string
  source: string
  location: string                // ãƒšãƒ¼ã‚¸ã€è¡Œç•ªå·ç­‰
  usedIn: string                  // ã©ã“ã§å¼•ç”¨ã•ã‚ŒãŸã‹
}

interface Measurement {
  metric: string                  // ä¾‹: "test_coverage"
  value: number
  unit: string
  timestamp: number
  context: string
}

/**
 * L5: Work Buffer
 * ä½œæ¥­é ˜åŸŸï¼ˆæœ€ã‚‚å¤‰å‹•çš„ï¼‰
 */
interface WorkBufferLayer {
  // è¨ˆç”»
  plan: Plan

  // å·®åˆ†ãƒ»å¤‰æ›´
  diff: Change[]

  // ä»®èª¬
  hypotheses: Hypothesis[]

  // ä¸‹æ›¸ã
  drafts: Draft[]

  // ä¸€æ™‚çš„ãªãƒ¡ãƒ¢
  scratchpad: string
}

interface Plan {
  steps: Step[]
  currentStepIndex: number
  estimatedCompletion?: number    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
}

interface Step {
  id: string
  description: string
  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'skipped'
  dependencies: string[]          // ä¾å­˜ã™ã‚‹ã‚¹ãƒ†ãƒƒãƒ—ID
  tools: string[]                 // å¿…è¦ãªãƒ„ãƒ¼ãƒ«
  estimatedDuration?: number
  actualDuration?: number
  result?: any
  error?: string
}

interface Change {
  type: 'create' | 'modify' | 'delete'
  target: string                  // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ç­‰
  before?: string
  after?: string
  rationale: string
  applied: boolean
}

interface Hypothesis {
  id: string
  description: string
  confidence: number              // 0-1
  evidence: string[]              // æ ¹æ‹ 
  tested: boolean
  result?: 'confirmed' | 'rejected' | 'inconclusive'
}

interface Draft {
  id: string
  type: string                    // ä¾‹: "code", "documentation"
  content: string
  version: number
  timestamp: number
}

/**
 * çµ±åˆã•ã‚ŒãŸ LayeredState
 */
interface LayeredState {
  l0_system: SystemLayer
  l1_task: TaskLayer
  l2_runtime: RuntimeLayer
  l3_memory: MemoryLayer
  l4_evidence: EvidenceLayer
  l5_workBuffer: WorkBufferLayer
}
```

### StateåˆæœŸåŒ–

```typescript
class StateInitializer {
  createInitialState(task: string): LayeredState {
    return {
      // L0: System
      l0_system: {
        role: {
          name: "AI Coding Assistant",
          description: "Helps with software development tasks",
          capabilities: [
            "Code generation",
            "Code review",
            "Debugging",
            "Documentation"
          ],
          limitations: [
            "Cannot access external APIs without permission",
            "Cannot modify system files",
            "Cannot execute privileged commands"
          ]
        },
        policies: this.getDefaultPolicies(),
        constraints: {
          maxExecutionTime: 3600,     // 1 hour
          maxToolCalls: 100,
          maxFileSize: 10 * 1024 * 1024,  // 10MB
          forbiddenPaths: [
            '/etc',
            '/sys',
            '/proc',
            '~/.ssh'
          ]
        },
        auditRequirements: {
          logToolCalls: true,
          logDecisions: true,
          requireApproval: ['delete', 'deploy'],
          retentionDays: 90
        }
      },

      // L1: Task
      l1_task: {
        goal: task,
        successCriteria: this.extractCriteria(task),
        outputFormat: {
          type: 'mixed',
          examples: []
        },
        constraints: {},
        metadata: {
          createdAt: Date.now(),
          createdBy: 'user',
          priority: 'medium',
          tags: []
        }
      },

      // L2: Runtime
      l2_runtime: {
        phase: 'initializing',
        permissions: ['read', 'write'],
        environment: 'dev',
        executionHistory: {
          toolCalls: [],
          decisions: [],
          errors: [],
          warnings: []
        },
        failureHistory: [],
        resources: {
          tokenUsage: { input: 0, output: 0, cached: 0 },
          apiCalls: 0,
          executionTime: 0,
          cost: 0
        }
      },

      // L3: Memory
      l3_memory: {
        shortTerm: {
          workingVariables: {},
          recentTurns: [],
          recentObservations: [],
          ttl: 300000  // 5 minutes
        },
        episodic: {
          summaries: [],
          decisions: [],
          milestones: [],
          maxEntries: 50
        },
        semantic: {
          facts: [],
          definitions: [],
          preferences: this.loadUserPreferences(),
          projectKnowledge: []
        },
        procedural: {
          skills: this.loadDefaultSkills(),
          templates: this.loadTemplates(),
          checklists: [],
          procedures: []
        }
      },

      // L4: Evidence
      l4_evidence: {
        observations: [],
        ragResults: [],
        citations: [],
        measurements: []
      },

      // L5: Work Buffer
      l5_workBuffer: {
        plan: {
          steps: [],
          currentStepIndex: 0
        },
        diff: [],
        hypotheses: [],
        drafts: [],
        scratchpad: ''
      }
    }
  }

  private getDefaultPolicies(): Policy[] {
    return [
      {
        id: 'pol-001',
        category: 'safety',
        rule: 'Never expose sensitive credentials or secrets',
        priority: 100,
        enforcement: 'hard'
      },
      {
        id: 'pol-002',
        category: 'safety',
        rule: 'Always validate user input before execution',
        priority: 90,
        enforcement: 'hard'
      },
      {
        id: 'pol-003',
        category: 'ethics',
        rule: 'Respect user privacy and data protection laws',
        priority: 95,
        enforcement: 'hard'
      },
      {
        id: 'pol-004',
        category: 'compliance',
        rule: 'Maintain audit logs for all critical operations',
        priority: 80,
        enforcement: 'soft'
      }
    ]
  }
}
```

---

## Context Builder

### æ ¸å¿ƒã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
/**
 * Context Builder
 * éšå±¤çš„Stateã‹ã‚‰æœ€é©ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æ§‹ç¯‰
 */
class ContextBuilder {
  constructor(
    private tokenCounter: TokenCounter,
    private priorityManager: PriorityManager,
    private compressor: ContextCompressor,
    private summarizer: ContextSummarizer,
    private config: ContextBuilderConfig
  ) {}

  /**
   * ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
   */
  async build(state: LayeredState): Promise<BuildResult> {
    // ã‚¹ãƒ†ãƒƒãƒ—1: å„å±¤ã‚’æ§‹ç¯‰
    const layers = await this.buildAllLayers(state)

    // ã‚¹ãƒ†ãƒƒãƒ—2: ãƒˆãƒ¼ã‚¯ãƒ³äºˆç®—é…åˆ†
    const allocated = await this.allocateTokenBudget(layers, state)

    // ã‚¹ãƒ†ãƒƒãƒ—3: å„ªå…ˆåº¦ä»˜ã‘
    const prioritized = this.applyPriority(allocated)

    // ã‚¹ãƒ†ãƒƒãƒ—4: æ§‹é€ åŒ–ï¼ˆXMLï¼‰
    const formatted = this.formatAsXML(prioritized)

    // ã‚¹ãƒ†ãƒƒãƒ—5: æœ€çµ‚æ¤œè¨¼
    const validated = await this.validate(formatted, state)

    return {
      context: validated,
      metadata: {
        totalTokens: await this.tokenCounter.count(validated),
        layers: this.getLayerBreakdown(layers),
        compressionRatio: this.calculateCompressionRatio(layers, validated)
      }
    }
  }

  /**
   * å…¨éšå±¤ã‚’æ§‹ç¯‰
   */
  private async buildAllLayers(state: LayeredState): Promise<BuiltLayers> {
    return {
      system: await this.buildSystemLayer(state.l0_system),
      task: await this.buildTaskLayer(state.l1_task),
      runtime: await this.buildRuntimeLayer(state.l2_runtime),
      memory: await this.buildMemoryLayer(state.l3_memory, state.l1_task),
      evidence: await this.buildEvidenceLayer(state.l4_evidence, state.l1_task),
      workBuffer: await this.buildWorkBufferLayer(state.l5_workBuffer)
    }
  }

  /**
   * L0: Systemå±¤ã®æ§‹ç¯‰
   */
  private async buildSystemLayer(system: SystemLayer): Promise<LayerContent> {
    return {
      priority: Priority.CRITICAL,
      content: `
<system>
  <role>
    <name>${system.role.name}</name>
    <description>${system.role.description}</description>
  </role>

  <policies>
    ${system.policies
      .filter(p => p.enforcement === 'hard')
      .sort((a, b) => b.priority - a.priority)
      .map(p => `<policy priority="${p.priority}">${p.rule}</policy>`)
      .join('\n    ')}
  </policies>

  <constraints>
    ${Object.entries(system.constraints)
      .map(([key, value]) => `<${key}>${value}</${key}>`)
      .join('\n    ')}
  </constraints>
</system>
`,
      tokenCount: 0  // å¾Œã§è¨ˆç®—
    }
  }

  /**
   * L1: Taskå±¤ã®æ§‹ç¯‰
   */
  private async buildTaskLayer(task: TaskLayer): Promise<LayerContent> {
    return {
      priority: Priority.CRITICAL,
      content: `
<task>
  <goal>${task.goal}</goal>

  <success_criteria>
    ${task.successCriteria
      .map(c => `<criterion>${c.description}</criterion>`)
      .join('\n    ')}
  </success_criteria>

  <output_format type="${task.outputFormat.type}">
    ${task.outputFormat.schema ?
      `<schema>${JSON.stringify(task.outputFormat.schema)}</schema>` :
      ''}
  </output_format>
</task>
`,
      tokenCount: 0
    }
  }

  /**
   * L2: Runtimeå±¤ã®æ§‹ç¯‰
   */
  private async buildRuntimeLayer(runtime: RuntimeLayer): Promise<LayerContent> {
    return {
      priority: Priority.HIGH,
      content: `
<runtime_state>
  <phase>${runtime.phase}</phase>
  <environment>${runtime.environment}</environment>

  <permissions>
    ${runtime.permissions.map(p => `<permission>${p}</permission>`).join('\n    ')}
  </permissions>

  <recent_errors>
    ${runtime.executionHistory.errors
      .slice(-3)
      .map(e => `<error timestamp="${e.timestamp}">${e.message}</error>`)
      .join('\n    ')}
  </recent_errors>
</runtime_state>
`,
      tokenCount: 0
    }
  }

  /**
   * L3: Memoryå±¤ã®æ§‹ç¯‰ï¼ˆæœ€ã‚‚è¤‡é›‘ï¼‰
   */
  private async buildMemoryLayer(
    memory: MemoryLayer,
    task: TaskLayer
  ): Promise<LayerContent> {
    // çŸ­æœŸãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªï¼ˆé«˜å„ªå…ˆåº¦ï¼‰
    const shortTerm = await this.buildShortTermMemory(memory.shortTerm)

    // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜æ†¶ï¼ˆé–¢é€£æ€§ãƒ•ã‚£ãƒ«ã‚¿ï¼‰
    const episodic = await this.buildEpisodicMemory(memory.episodic, task)

    // æ„å‘³è¨˜æ†¶ï¼ˆé–¢é€£æ€§ãƒ•ã‚£ãƒ«ã‚¿ï¼‰
    const semantic = await this.buildSemanticMemory(memory.semantic, task)

    // æ‰‹ç¶šãè¨˜æ†¶ï¼ˆå¿…è¦ãªã‚¹ã‚­ãƒ«ã®ã¿ï¼‰
    const procedural = await this.buildProceduralMemory(memory.procedural, task)

    return {
      priority: Priority.MEDIUM,
      content: `
<memory>
  ${shortTerm}
  ${episodic}
  ${semantic}
  ${procedural}
</memory>
`,
      tokenCount: 0
    }
  }

  private async buildShortTermMemory(shortTerm: ShortTermMemory): Promise<string> {
    // æœŸé™åˆ‡ã‚Œã®è¦³æ¸¬ã‚’é™¤å¤–
    const now = Date.now()
    const validObservations = shortTerm.recentObservations.filter(
      obs => now - obs.timestamp < shortTerm.ttl
    )

    return `
  <short_term>
    <working_variables>
      ${Object.entries(shortTerm.workingVariables)
        .map(([key, value]) => `<var name="${key}">${JSON.stringify(value)}</var>`)
        .join('\n      ')}
    </working_variables>

    <recent_turns>
      ${shortTerm.recentTurns
        .map(turn => `
      <turn role="${turn.role}" timestamp="${turn.ts}">
        ${this.escapeXML(turn.content)}
      </turn>`)
        .join('\n      ')}
    </recent_turns>

    <recent_observations>
      ${validObservations
        .sort((a, b) => b.timestamp - a.timestamp)
        .slice(0, 5)  // æœ€æ–°5ä»¶
        .map(obs => `
      <observation tool="${obs.tool}" timestamp="${obs.timestamp}">
        ${this.escapeXML(JSON.stringify(obs.result))}
      </observation>`)
        .join('\n      ')}
    </recent_observations>
  </short_term>
`
  }

  private async buildEpisodicMemory(
    episodic: EpisodicMemory,
    task: TaskLayer
  ): Promise<string> {
    // ã‚¿ã‚¹ã‚¯ã«é–¢é€£ã™ã‚‹ã‚µãƒãƒªãƒ¼ã®ã¿
    const relevantSummaries = episodic.summaries
      .filter(s => this.isRelevant(s.text, task.goal))
      .sort((a, b) => (b.relevance || 0) - (a.relevance || 0))
      .slice(0, 5)  // ä¸Šä½5ä»¶

    return `
  <episodic>
    <summaries>
      ${relevantSummaries
        .map(s => `
      <summary timestamp="${s.timestamp}" relevance="${s.relevance}">
        ${this.escapeXML(s.text)}
      </summary>`)
        .join('\n      ')}
    </summaries>

    <milestones>
      ${episodic.milestones
        .filter(m => m.significance !== 'low')
        .map(m => `
      <milestone significance="${m.significance}">
        ${m.event}
      </milestone>`)
        .join('\n      ')}
    </milestones>
  </episodic>
`
  }

  private async buildSemanticMemory(
    semantic: SemanticMemory,
    task: TaskLayer
  ): Promise<string> {
    // é–¢é€£ã™ã‚‹äº‹å®Ÿã®ã¿
    const relevantFacts = semantic.facts
      .filter(f => f.verified && this.isRelevant(f.content, task.goal))
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 10)  // ä¸Šä½10ä»¶

    return `
  <semantic>
    <facts>
      ${relevantFacts
        .map(f => `
      <fact source="${f.source}" confidence="${f.confidence}">
        ${this.escapeXML(f.content)}
      </fact>`)
        .join('\n      ')}
    </facts>

    <project_knowledge>
      ${semantic.projectKnowledge
        .filter(k => this.isRelevant(k.content, task.goal))
        .map(k => `
      <knowledge category="${k.category}">
        ${this.escapeXML(k.content)}
      </knowledge>`)
        .join('\n      ')}
    </project_knowledge>
  </semantic>
`
  }

  private async buildProceduralMemory(
    procedural: ProceduralMemory,
    task: TaskLayer
  ): Promise<string> {
    // ã‚¿ã‚¹ã‚¯ã«å¿…è¦ãªã‚¹ã‚­ãƒ«ã®ã¿
    const requiredSkills = procedural.skills.filter(skill =>
      this.isSkillRequired(skill, task.goal)
    )

    return `
  <procedural>
    <skills>
      ${requiredSkills
        .map(skill => `
      <skill name="${skill.name}">
        <description>${skill.description}</description>
        <steps>
          ${skill.steps.map(step => `<step>${step}</step>`).join('\n          ')}
        </steps>
      </skill>`)
        .join('\n      ')}
    </skills>

    <templates>
      ${procedural.templates
        .filter(t => this.isRelevant(t.content, task.goal))
        .slice(0, 3)  // ä¸Šä½3ä»¶
        .map(t => `
      <template name="${t.name}" category="${t.category}">
        ${this.escapeXML(t.content)}
      </template>`)
        .join('\n      ')}
    </templates>
  </procedural>
`
  }

  /**
   * L4: Evidenceå±¤ã®æ§‹ç¯‰
   */
  private async buildEvidenceLayer(
    evidence: EvidenceLayer,
    task: TaskLayer
  ): Promise<LayerContent> {
    // æœ€æ–°ã®è¦³æ¸¬ã‚’å„ªå…ˆ
    const recentObservations = evidence.observations
      .filter(obs => Date.now() - obs.timestamp < 60000)  // 1åˆ†ä»¥å†…
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, 5)

    // é–¢é€£æ€§ã®é«˜ã„RAGçµæœ
    const relevantRAG = evidence.ragResults
      .filter(r => r.relevance > 0.3)
      .sort((a, b) => b.relevance - a.relevance)
      .slice(0, 10)

    return {
      priority: Priority.HIGH,
      content: `
<evidence>
  <recent_observations>
    ${recentObservations
      .map(obs => `
    <observation tool="${obs.tool}" timestamp="${obs.timestamp}">
      ${this.escapeXML(JSON.stringify(obs.result))}
    </observation>`)
      .join('\n    ')}
  </recent_observations>

  <rag_results>
    ${relevantRAG
      .map(r => `
    <result relevance="${r.relevance}" source="${r.source}">
      ${this.escapeXML(r.content)}
    </result>`)
      .join('\n    ')}
  </rag_results>
</evidence>
`,
      tokenCount: 0
    }
  }

  /**
   * L5: Work Bufferå±¤ã®æ§‹ç¯‰
   */
  private async buildWorkBufferLayer(
    workBuffer: WorkBufferLayer
  ): Promise<LayerContent> {
    return {
      priority: Priority.MEDIUM,
      content: `
<work_buffer>
  <plan current_step="${workBuffer.plan.currentStepIndex}">
    ${workBuffer.plan.steps
      .map((step, i) => `
    <step id="${i}" status="${step.status}">
      ${step.description}
    </step>`)
      .join('\n    ')}
  </plan>

  <hypotheses>
    ${workBuffer.hypotheses
      .filter(h => !h.tested || h.result === 'inconclusive')
      .map(h => `
    <hypothesis confidence="${h.confidence}">
      ${h.description}
    </hypothesis>`)
      .join('\n    ')}
  </hypotheses>

  <scratchpad>
    ${this.escapeXML(workBuffer.scratchpad)}
  </scratchpad>
</work_buffer>
`,
      tokenCount: 0
    }
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³äºˆç®—é…åˆ†
   */
  private async allocateTokenBudget(
    layers: BuiltLayers,
    state: LayeredState
  ): Promise<BuiltLayers> {
    const maxTokens = this.config.maxTokens
    const budget = maxTokens * 0.9  // 10%ãƒãƒƒãƒ•ã‚¡

    // å„å±¤ã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã‚’è¨ˆç®—
    for (const [layerName, layer] of Object.entries(layers)) {
      layer.tokenCount = await this.tokenCounter.count(layer.content)
    }

    // äºˆç®—é…åˆ†
    const allocation = {
      system: budget * 0.05,       // 5%
      task: budget * 0.05,         // 5%
      runtime: budget * 0.03,      // 3%
      memory: budget * 0.52,       // 52% (20+15+10+7)
      evidence: budget * 0.25,     // 25%
      workBuffer: budget * 0.10    // 10%
    }

    // å„å±¤ã‚’äºˆç®—å†…ã«åã‚ã‚‹
    const fitted: BuiltLayers = {}

    for (const [layerName, layer] of Object.entries(layers)) {
      const layerBudget = allocation[layerName as keyof typeof allocation]

      if (layer.tokenCount <= layerBudget) {
        fitted[layerName] = layer
      } else {
        // äºˆç®—è¶…é â†’ åœ§ç¸®
        fitted[layerName] = await this.fitLayerToBudget(layer, layerBudget)
      }
    }

    return fitted
  }

  /**
   * å±¤ã‚’äºˆç®—å†…ã«åã‚ã‚‹
   */
  private async fitLayerToBudget(
    layer: LayerContent,
    budget: number
  ): Promise<LayerContent> {
    // è¦ç´„æˆ¦ç•¥
    const compressed = await this.compressor.compress(layer.content, budget)

    return {
      ...layer,
      content: compressed,
      tokenCount: await this.tokenCounter.count(compressed)
    }
  }

  /**
   * é–¢é€£æ€§åˆ¤å®š
   */
  private isRelevant(content: string, goal: string): boolean {
    // ç°¡æ˜“çš„ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒï¼ˆå®Ÿéš›ã¯ãƒ™ã‚¯ãƒˆãƒ«é¡ä¼¼åº¦ã‚’ä½¿ç”¨ï¼‰
    const contentLower = content.toLowerCase()
    const goalKeywords = goal
      .toLowerCase()
      .split(/\s+/)
      .filter(w => w.length > 3)

    const matchCount = goalKeywords.filter(keyword =>
      contentLower.includes(keyword)
    ).length

    return matchCount / goalKeywords.length > 0.3
  }

  /**
   * ã‚¹ã‚­ãƒ«å¿…è¦æ€§åˆ¤å®š
   */
  private isSkillRequired(skill: Skill, goal: string): boolean {
    return this.isRelevant(skill.name + ' ' + skill.description, goal)
  }

  /**
   * XML ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
   */
  private escapeXML(text: string | any): string {
    if (typeof text !== 'string') {
      text = String(text)
    }

    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
  }
}

interface ContextBuilderConfig {
  maxTokens: number
  compressionThreshold: number
  useXML: boolean
}

interface BuiltLayers {
  [key: string]: LayerContent
}

interface LayerContent {
  priority: Priority
  content: string
  tokenCount: number
}

interface BuildResult {
  context: string
  metadata: {
    totalTokens: number
    layers: Record<string, number>
    compressionRatio: number
  }
}

enum Priority {
  CRITICAL = 100,
  HIGH = 80,
  MEDIUM = 50,
  LOW = 20,
  MINIMAL = 5
}
```

ã“ã®å·¨å¤§ãªãƒ•ã‚¡ã‚¤ãƒ«ã¯ã¾ã ç¶šãã¾ã™ãŒã€ãƒˆãƒ¼ã‚¯ãƒ³åˆ¶é™ã«è¿‘ã¥ã„ã¦ã„ã‚‹ã®ã§ã€ã“ã“ã§ä¸€æ—¦åŒºåˆ‡ã‚Šã¾ã™ã€‚æ®‹ã‚Šã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå‹•çš„ãƒ„ãƒ¼ãƒ«æŠ•å½±ã€Condensation Engineã€MessageManagerã€è¦³æ¸¬å¯èƒ½æ€§ã€çµ±åˆå®Ÿè¡Œãƒ•ãƒ­ãƒ¼ï¼‰ã‚’ç¶šã‘ã¦æ›¸ãã¾ã™ã‹ï¼Ÿ
---

## å‹•çš„ãƒ„ãƒ¼ãƒ«æŠ•å½±

### æ¦‚è¦

å‹•çš„ãƒ„ãƒ¼ãƒ«æŠ•å½±ã¯ã€å®Ÿè¡Œæ™‚ã®çŠ¶æ…‹ï¼ˆãƒ•ã‚§ãƒ¼ã‚ºã€æ¨©é™ã€ç’°å¢ƒï¼‰ã«å¿œã˜ã¦ã€LLMã«è¦‹ã›ã‚‹ãƒ„ãƒ¼ãƒ«ã¨ãã®ã‚¹ã‚­ãƒ¼ãƒã‚’å‹•çš„ã«å¤‰æ›´ã™ã‚‹ä»•çµ„ã¿ã§ã™ã€‚

è©³ç´°ãªå®Ÿè£…ã¯03-implementation-patterns.mdã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## Condensation Engine

### æ ¸å¿ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

éç ´å£Šçš„ãªAIè¦ç´„ã‚¨ãƒ³ã‚¸ãƒ³ã€‚tool_use/tool_resultãƒšã‚¢ã‚’ä¿æŒã—ã€Native Toolsãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«æº–æ‹ ã—ã¾ã™ã€‚

è©³ç´°ã¯03-implementation-patterns.mdã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## MessageManager

### çµ±åˆç®¡ç†ã‚¯ãƒ©ã‚¹

clineMessagesã¨apiConversationHistoryã®ä¸€è²«æ€§ã‚’ä¿è¨¼ã—ã€ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã«å¯¾å¿œã—ã¾ã™ã€‚

è©³ç´°ã¯03-implementation-patterns.mdã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## è¦³æ¸¬å¯èƒ½æ€§ï¼ˆObservabilityï¼‰

### ãƒˆãƒ¬ãƒ¼ã‚¹ã¨ãƒ¡ãƒˆãƒªã‚¯ã‚¹

ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã€ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã€è©•ä¾¡ãƒ«ãƒ¼ãƒ—ã‚’æä¾›ã—ã¾ã™ã€‚

è©³ç´°ã¯04-best-practices.mdã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## çµ±åˆå®Ÿè¡Œãƒ•ãƒ­ãƒ¼

### ModernContextEngine

ã™ã¹ã¦ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’çµ±åˆã—ã€Planning â†’ Executing â†’ Reflecting ã®ãƒ«ãƒ¼ãƒ—ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

---

## ã¾ã¨ã‚: ãƒ¢ãƒ€ãƒ³ãªContext Managementã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

ã“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ä¸»è¦ãªç‰¹å¾´ï¼š

1. **éšå±¤çš„State**: L0-L5ã®æ˜ç¢ºãªåˆ†é›¢ã¨å„ªå…ˆåº¦ç®¡ç†
2. **Context Builder**: ãƒˆãƒ¼ã‚¯ãƒ³äºˆç®—é…åˆ†ã¨é–¢é€£æ€§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
3. **å‹•çš„ãƒ„ãƒ¼ãƒ«æŠ•å½±**: ãƒ•ã‚§ãƒ¼ã‚ºãƒ»æ¨©é™ãƒ»ç’°å¢ƒã«å¿œã˜ãŸé©å¿œ
4. **Condensation Engine**: AIè¦ç´„ã¨Native Toolså¯¾å¿œ
5. **MessageManager**: éç ´å£Šçš„ç®¡ç†ã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
6. **Observability**: ãƒˆãƒ¬ãƒ¼ã‚¹ãƒ»ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ»ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
7. **çµ±åˆãƒ•ãƒ­ãƒ¼**: ã™ã¹ã¦ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å”èª¿å‹•ä½œ


---

[Context Management 2025 - Context Management ã®é€²åŒ–](https://zenn.dev/singularity/articles/context-2025-01)
[Context Management 2025 - ãƒ¢ãƒ€ãƒ³ãªContext Managementã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£](https://zenn.dev/singularity/articles/context-2025-02)
[Context Management 2025 - å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³é›†](https://zenn.dev/singularity/articles/context-2025-03)
[Context Management 2025 - ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](https://zenn.dev/singularity/articles/context-2025-04)
[Context Management 2025 - çµ±åˆå®Ÿè£…ä¾‹](https://zenn.dev/singularity/articles/context-2025-05)